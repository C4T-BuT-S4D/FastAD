// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: scoreboard/scoreboard.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "scoreboard";

export interface TeamServiceState {
  teamId: bigint;
  serviceId: bigint;
  checksTotal: bigint;
  checksPassed: bigint;
}

export interface Scoreboard {
  teamServiceStates: TeamServiceState[];
}

export interface GetStateRequest {
}

export interface GetStateResponse {
  scoreboard: Scoreboard | undefined;
}

function createBaseTeamServiceState(): TeamServiceState {
  return { teamId: 0n, serviceId: 0n, checksTotal: 0n, checksPassed: 0n };
}

export const TeamServiceState: MessageFns<TeamServiceState> = {
  encode(message: TeamServiceState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== 0n) {
      if (BigInt.asIntN(64, message.teamId) !== message.teamId) {
        throw new globalThis.Error("value provided for field message.teamId of type int64 too large");
      }
      writer.uint32(8).int64(message.teamId);
    }
    if (message.serviceId !== 0n) {
      if (BigInt.asIntN(64, message.serviceId) !== message.serviceId) {
        throw new globalThis.Error("value provided for field message.serviceId of type int64 too large");
      }
      writer.uint32(16).int64(message.serviceId);
    }
    if (message.checksTotal !== 0n) {
      if (BigInt.asIntN(64, message.checksTotal) !== message.checksTotal) {
        throw new globalThis.Error("value provided for field message.checksTotal of type int64 too large");
      }
      writer.uint32(24).int64(message.checksTotal);
    }
    if (message.checksPassed !== 0n) {
      if (BigInt.asIntN(64, message.checksPassed) !== message.checksPassed) {
        throw new globalThis.Error("value provided for field message.checksPassed of type int64 too large");
      }
      writer.uint32(32).int64(message.checksPassed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamServiceState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamServiceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.int64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.checksTotal = reader.int64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.checksPassed = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TeamServiceState, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<TeamServiceState | TeamServiceState[]> | Iterable<TeamServiceState | TeamServiceState[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TeamServiceState.encode(p).finish()];
        }
      } else {
        yield* [TeamServiceState.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TeamServiceState>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TeamServiceState> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TeamServiceState.decode(p)];
        }
      } else {
        yield* [TeamServiceState.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TeamServiceState {
    return {
      teamId: isSet(object.teamId) ? BigInt(object.teamId) : 0n,
      serviceId: isSet(object.serviceId) ? BigInt(object.serviceId) : 0n,
      checksTotal: isSet(object.checksTotal) ? BigInt(object.checksTotal) : 0n,
      checksPassed: isSet(object.checksPassed) ? BigInt(object.checksPassed) : 0n,
    };
  },

  toJSON(message: TeamServiceState): unknown {
    const obj: any = {};
    if (message.teamId !== 0n) {
      obj.teamId = message.teamId.toString();
    }
    if (message.serviceId !== 0n) {
      obj.serviceId = message.serviceId.toString();
    }
    if (message.checksTotal !== 0n) {
      obj.checksTotal = message.checksTotal.toString();
    }
    if (message.checksPassed !== 0n) {
      obj.checksPassed = message.checksPassed.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeamServiceState>, I>>(base?: I): TeamServiceState {
    return TeamServiceState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeamServiceState>, I>>(object: I): TeamServiceState {
    const message = createBaseTeamServiceState();
    message.teamId = object.teamId ?? 0n;
    message.serviceId = object.serviceId ?? 0n;
    message.checksTotal = object.checksTotal ?? 0n;
    message.checksPassed = object.checksPassed ?? 0n;
    return message;
  },
};

function createBaseScoreboard(): Scoreboard {
  return { teamServiceStates: [] };
}

export const Scoreboard: MessageFns<Scoreboard> = {
  encode(message: Scoreboard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.teamServiceStates) {
      TeamServiceState.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scoreboard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreboard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.teamServiceStates.push(TeamServiceState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Scoreboard, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Scoreboard | Scoreboard[]> | Iterable<Scoreboard | Scoreboard[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Scoreboard.encode(p).finish()];
        }
      } else {
        yield* [Scoreboard.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Scoreboard>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Scoreboard> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Scoreboard.decode(p)];
        }
      } else {
        yield* [Scoreboard.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Scoreboard {
    return {
      teamServiceStates: globalThis.Array.isArray(object?.teamServiceStates)
        ? object.teamServiceStates.map((e: any) => TeamServiceState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Scoreboard): unknown {
    const obj: any = {};
    if (message.teamServiceStates?.length) {
      obj.teamServiceStates = message.teamServiceStates.map((e) => TeamServiceState.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Scoreboard>, I>>(base?: I): Scoreboard {
    return Scoreboard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Scoreboard>, I>>(object: I): Scoreboard {
    const message = createBaseScoreboard();
    message.teamServiceStates = object.teamServiceStates?.map((e) => TeamServiceState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetStateRequest(): GetStateRequest {
  return {};
}

export const GetStateRequest: MessageFns<GetStateRequest> = {
  encode(_: GetStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetStateRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<GetStateRequest | GetStateRequest[]> | Iterable<GetStateRequest | GetStateRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetStateRequest.encode(p).finish()];
        }
      } else {
        yield* [GetStateRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetStateRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetStateRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetStateRequest.decode(p)];
        }
      } else {
        yield* [GetStateRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): GetStateRequest {
    return {};
  },

  toJSON(_: GetStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStateRequest>, I>>(base?: I): GetStateRequest {
    return GetStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStateRequest>, I>>(_: I): GetStateRequest {
    const message = createBaseGetStateRequest();
    return message;
  },
};

function createBaseGetStateResponse(): GetStateResponse {
  return { scoreboard: undefined };
}

export const GetStateResponse: MessageFns<GetStateResponse> = {
  encode(message: GetStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scoreboard !== undefined) {
      Scoreboard.encode(message.scoreboard, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scoreboard = Scoreboard.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetStateResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<GetStateResponse | GetStateResponse[]> | Iterable<GetStateResponse | GetStateResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetStateResponse.encode(p).finish()];
        }
      } else {
        yield* [GetStateResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetStateResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetStateResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetStateResponse.decode(p)];
        }
      } else {
        yield* [GetStateResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetStateResponse {
    return { scoreboard: isSet(object.scoreboard) ? Scoreboard.fromJSON(object.scoreboard) : undefined };
  },

  toJSON(message: GetStateResponse): unknown {
    const obj: any = {};
    if (message.scoreboard !== undefined) {
      obj.scoreboard = Scoreboard.toJSON(message.scoreboard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStateResponse>, I>>(base?: I): GetStateResponse {
    return GetStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStateResponse>, I>>(object: I): GetStateResponse {
    const message = createBaseGetStateResponse();
    message.scoreboard = (object.scoreboard !== undefined && object.scoreboard !== null)
      ? Scoreboard.fromPartial(object.scoreboard)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  encodeTransform(source: AsyncIterable<T | T[]> | Iterable<T | T[]>): AsyncIterable<Uint8Array>;
  decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<T>;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
